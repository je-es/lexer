{"version":3,"sources":["../lib/lexer.ts"],"sourcesContent":["// lexer.ts — A tool for converting text into tokens.\n//\n// repo   : https://github.com/je-es/lexer\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    // Represents a token with kind, value and position information\n    export interface Token {\n        kind                : string;\n        value               : string | null;\n        span                : Span;\n    }\n\n    // Represents a span in the source text\n    export interface Span {\n        start               : number;\n        end                 : number;\n    }\n\n    // Configuration for a lexer rule defining how to match and process tokens\n    export interface RuleConfig {\n        match               : RegExp;\n        value               ?: (text: string) => string;\n        lineBreaks          ?: boolean;\n        priority            ?: number; // Higher numbers = higher priority\n    }\n\n    // Defines a rule that can be a string, RegExp, string array, or RuleConfig\n    export type Rule = string | RegExp | string[] | RuleConfig;\n\n    // Collection of named rules for tokenization\n    export type Rules = Record<string, Rule>;\n\n    // Options for tokenization behavior\n    export interface TokenizeOptions {\n        continueOnError    ?: boolean; // Default: false (stop at first error)\n    }\n\n    // Internal representation of a compiled rule\n    export interface CompiledRule {\n        pattern             : string;\n        name                : string;\n        transform           : ((text: string) => string) | null;\n        lineBreaks          : boolean;\n        priority            : number;\n        originalLength      : number;\n    }\n\n    // Special symbol to denote error rules\n    export const error = Symbol('error');\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    // Lexer class that tokenizes input based on provided rules.\n    export class Lexer {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private fastRegex       : RegExp | null                         = null;\n            private ruleTypes       : string[]                              = [];\n            private ruleTransforms  : (((text: string) => string) | null)[] = [];\n            private ruleLineBreaks  : boolean[]                             = []; // [TODO] review it.\n            private buffer          : string                                = '';\n            private position        : number                                = 0;\n            private length          : number                                = 0;\n\n            constructor(rules: Rules) {\n                this.compileRules(rules);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            setup(input: string): void {\n                this.buffer     = input;\n                this.length     = input.length;\n                this.position   = 0;\n\n                if (this.fastRegex) {\n                    this.fastRegex.lastIndex = 0;\n                }\n            }\n\n            next(): Token | undefined {\n                // Early exit for end of input\n                if (this.position >= this.length) {\n                    return undefined;\n                }\n\n                if (this.fastRegex) {\n                    this.fastRegex.lastIndex    = this.position;\n                    const match                 = this.fastRegex.exec(this.buffer);\n\n                    if (match && match.index === this.position) {\n                        // Find which group matched - optimized loop\n                        let ruleIndex   = -1;\n                        let text        = '';\n\n                        // Start from index 1 (skip full match)\n                        for (let i = 1; i < match.length; i++) {\n                            if (match[i] !== undefined) {\n                                ruleIndex   = i - 1;\n                                text        = match[i];\n                                break;\n                            }\n                        }\n\n                        if (ruleIndex >= 0) {\n                            const startPos  = this.position;\n                            this.position  += text.length;\n\n                            // Apply transformation if exists\n                            const transform = this.ruleTransforms[ruleIndex];\n                            const value     = transform ? transform(text) : text;\n\n                            return {\n                                kind    : this.ruleTypes[ruleIndex],\n                                value   : value || null,\n                                span    : { start: startPos, end: this.position }\n                            };\n                        }\n                    }\n                }\n\n                // Enhanced error recovery: consume problematic character and continue\n                const char      = this.buffer[this.position];\n                const startPos  = this.position;\n                this.position++;\n\n                return {\n                    kind    : 'error',\n                    value   : char,\n                    span    : { start: startPos, end: this.position }\n                };\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private compileRules(rules: Rules): void {\n                const compiledRules: CompiledRule[] = [];\n\n                // String to Array\n                for (const [name, rule] of Object.entries(rules)) {\n                    if (typeof rule === 'string') {\n                        rules[name] = [rule];\n                    }\n                }\n\n                // First pass: compile all rules with proper prioritization\n                for (const [name, rule] of Object.entries(rules)) {\n                    if (typeof rule === 'symbol' && rule === error) { continue; }\n\n                    const compiled = this.compileRule(name, rule);\n                    compiledRules.push(...compiled);\n                }\n\n                // Sort rules by priority to ensure correct matching\n                compiledRules.sort((a, b) => {\n                    // Higher priority first\n                    if (a.priority !== b.priority) {\n                        return b.priority - a.priority;\n                    }\n\n                    // Longer patterns first (for same priority)\n                    if (a.originalLength !== b.originalLength) {\n                        return b.originalLength - a.originalLength;\n                    }\n\n                    // Alphabetical for consistency\n                    return a.name.localeCompare(b.name);\n                });\n\n                // Build optimized arrays\n                const patterns      : string[]                                  = [];\n                const types         : string[]                                  = [];\n                const transforms    : (((text: string) => string) | null)[]     = [];\n                const lineBreaks    : boolean[]                                 = [];\n\n                for (const rule of compiledRules) {\n                    patterns.push(`(${rule.pattern})`);\n                    types.push(rule.name);\n                    transforms.push(rule.transform);\n                    lineBreaks.push(rule.lineBreaks);\n                }\n\n                // Compile single mega-regex for maximum performance\n                if (patterns.length > 0) {\n                    this.fastRegex = new RegExp(patterns.join('|'), 'gy');\n                }\n\n                // Store as flat arrays for better cache performance\n                this.ruleTypes = types;\n                this.ruleTransforms = transforms;\n                this.ruleLineBreaks = lineBreaks;\n            }\n\n            private compileRule(name: string, rule: Rule): CompiledRule[] {\n                if (typeof rule === 'string') {\n                    throw new Error('String rules should be converted to string arrays before compilation.');\n                }\n\n                if (rule instanceof RegExp) {\n                    return [{\n                        pattern: rule.source,\n                        name,\n                        transform       : null,\n                        lineBreaks      : false,\n                        priority        : this.calculateBasePriority('regex') + rule.source.length * 5,\n                        originalLength  : rule.source.length\n                    }];\n                }\n\n                if (Array.isArray(rule)) {\n                    return this.compileStringArray(name, rule);\n                }\n\n                // RuleConfig\n                const config = rule as RuleConfig;\n                return [{\n                    pattern: config.match.source,\n                    name,\n                    transform       : config.value || null,\n                    lineBreaks      : config.lineBreaks || false,\n                    priority        : config.priority ?? (this.calculateBasePriority('regex') + config.match.source.length * 5),\n                    originalLength  : config.match.source.length\n                }];\n            }\n\n            private compileStringArray(name: string, strings: string[]): CompiledRule[] {\n                // Sort by length descending to ensure longest match wins\n                const sortedStrings = [...strings].sort((a, b) => b.length - a.length);\n\n                // Detect if strings are operators/punctuation vs keywords\n                const isKeywordLike = (str: string): boolean => /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str);\n                const keywords  = sortedStrings.filter(isKeywordLike);\n                const operators = sortedStrings.filter(s => !isKeywordLike(s));\n\n                const results: CompiledRule[] = [];\n\n                // Handle keywords with word boundaries\n                if (keywords.length > 0) {\n                    const pattern = `\\\\b(?:${keywords.map(k => this.escapeRegex(k)).join('|')})\\\\b`;\n\n                    results.push({\n                        pattern,\n                        name,\n                        transform       : null,\n                        lineBreaks      : false,\n                        priority        : this.calculateBasePriority('keyword') + Math.max(...keywords.map(k => k.length)) * 10,\n                        originalLength  : Math.max(...keywords.map(k => k.length))\n                    });\n                }\n\n                // Handle operators/punctuation without word boundaries\n                if (operators.length > 0) {\n                    const pattern = `(?:${operators.map(o => this.escapeRegex(o)).join('|')})`;\n\n                    results.push({\n                        pattern,\n                        name,\n                        transform       : null,\n                        lineBreaks      : false,\n                        priority        : this.calculateBasePriority('operator') + Math.max(...operators.map(o => o.length)) * 10,\n                        originalLength  : Math.max(...operators.map(o => o.length))\n                    });\n                }\n\n                return results;\n            }\n\n            private calculateBasePriority(type: 'regex' | 'keyword' | 'operator'): number {\n                // Higher numbers = higher priority\n                switch (type) {\n                    case 'keyword'  : return 1000;  // Keywords should match before identifiers\n                    case 'operator' : return 800;   // Multi-char operators before single chars\n                    case 'regex'    : return 600;   // Complex patterns\n                    default         : return 0;\n                }\n            }\n\n            private escapeRegex(str: string): string {\n                return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n            }\n\n            *[Symbol.iterator](): Iterator<Token> {\n                let token: Token | undefined;\n                while ((token = this.next()) !== undefined) { yield token; }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\n\n    /**\n    * Tokenizes source code using the provided rules\n    *\n    * @param source     - The source text to tokenize\n    * @param rules      - Rules defining how to break the source into tokens\n    * @param options    - Optional tokenization behavior settings\n    *\n    * @returns Array of tokens extracted from the source\n    */\n    export function tokenize(source: string, rules: Rules, options: TokenizeOptions = {}): Token[] {\n        // Early return for empty input\n        if (source.length === 0) { return []; }\n\n        const tokens: Token[] = [];\n        const lexer = new Lexer(rules);\n        const { continueOnError = false } = options; // Default: stop at first error (original behavior)\n\n        lexer.setup(source);\n\n        let token = lexer.next();\n        while (token !== undefined) {\n            tokens.push({\n                kind    : token.kind,\n                value   : token.value && token.value.length > 0 ? token.value : null,\n                span    : token.span\n            });\n\n            // Stop on first error (unless continueOnError is true)\n            if (token.kind === 'error' && !continueOnError) {\n                break;\n            }\n\n            token = lexer.next();\n        }\n\n        return tokens;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["startPos"]}