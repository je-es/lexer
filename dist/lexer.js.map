{"version":3,"sources":["../lib/lexer.ts"],"sourcesContent":["// lexer.ts — A tool for converting text into tokens..!\n//\n// repo   : https://github.com/je-es/lexer\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    // Represents a token with kind, value and position information\n    export interface Token {\n        kind                : string;\n        value               : string | null;\n        span                : Span;\n    }\n\n    // Represents a span in the source text\n    export interface Span {\n        start               : number;\n        end                 : number;\n    }\n\n    // Configuration for a lexer rule defining how to match and process tokens\n    export interface RuleConfig {\n        match               : RegExp;\n        value               ?: (text: string) => string;\n        lineBreaks          ?: boolean;\n    }\n\n    // Defines a rule that can be a string, RegExp, string array, or RuleConfig\n    export type Rule = string | RegExp | string[] | RuleConfig;\n\n    // Collection of named rules for tokenization\n    export interface Rules {\n        [key: string]: Rule;\n    }\n\n    // Special symbol to denote error rules\n    export const error = Symbol('error');\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    // Lexer class that tokenizes input based on provided rules.\n    export class Lexer {\n        private fastRegex       : RegExp | null                         = null;\n        private ruleTypes       : string[]                              = [];\n        private ruleTransforms  : (((text: string) => string) | null)[] = [];\n        private ruleLineBreaks  : boolean[]                             = [];\n        private buffer          : string                                = '';\n        private position        : number                                = 0;\n        private length          : number                                = 0;\n\n        constructor(rules: Rules) {\n            this.compileRules(rules);\n        }\n\n        private compileRules(rules: Rules): void {\n            const patterns      : string[]                              = [];\n            const types         : string[]                              = [];\n            const transforms    : (((text: string) => string) | null)[] = [];\n            const lineBreaks    : boolean[]                             = [];\n\n            for (let [name, rule] of Object.entries(rules)) {\n                let pattern         : string | undefined;\n                let transform       : ((text: string) => string) | null = null;\n                let hasLineBreaks   : boolean                           = false;\n\n                if (typeof rule === 'symbol' && rule === error) {\n                    // Skip error rule for now - handle in fallback\n                    continue;\n                } else if (typeof rule === 'string' || Array.isArray(rule)) {\n                    if (typeof rule === 'string') {\n                        // if is operator or punc (single or multi)\n                        if (!/^[a-zA-Z0-9_]+$/.test(rule)) {\n                            pattern = this.escapeRegex(rule);\n                        }\n\n                        // otherwise, it's a keyword\n                        else {\n                            rule = [rule];\n                        }\n                    }\n\n                    if (Array.isArray(rule)) {\n                        // This ensures keywords match only as complete words\n                        if (rule.length === 1) {\n                            pattern = `\\\\b${this.escapeRegex(rule[0])}\\\\b`;\n                        } else if (rule.length > 1) {\n                            pattern = `\\\\b(?:${rule.map(k => this.escapeRegex(k)).join('|')})\\\\b`;\n                        }\n                    }\n\n                } else if (rule instanceof RegExp) {\n                    pattern = rule.source;\n                } else {\n                    // RuleConfig\n                    const config = rule as RuleConfig;\n                    pattern = config.match.source;\n                    transform = config.value || null;\n                    hasLineBreaks = config.lineBreaks || false;\n                }\n\n                if (typeof pattern === 'undefined') {\n                    throw new Error(`Pattern for rule \"${name}\" could not be determined.`);\n                }\n\n                patterns.push(`(${pattern})`);\n                types.push(name);\n                transforms.push(transform);\n                lineBreaks.push(hasLineBreaks);\n            }\n\n            // Compile single mega-regex for maximum performance\n            if (patterns.length > 0) {\n                this.fastRegex = new RegExp(patterns.join('|'), 'gy');\n            }\n\n            // Store as flat arrays for better cache performance\n            this.ruleTypes = types;\n            this.ruleTransforms = transforms;\n            this.ruleLineBreaks = lineBreaks;\n        }\n\n        private escapeRegex(str: string): string {\n            return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        }\n\n        setup(input: string): void {\n            this.buffer = input;\n            this.length = input.length;\n            this.position = 0;\n\n            if (this.fastRegex) {\n                this.fastRegex.lastIndex = 0;\n            }\n        }\n\n        next(): Token | undefined {\n            // Early exit for end of input\n            if (this.position >= this.length) {\n                return undefined;\n            }\n\n            if (this.fastRegex) {\n                this.fastRegex.lastIndex = this.position;\n                const match = this.fastRegex.exec(this.buffer);\n\n                if (match && match.index === this.position) {\n                    // Find which group matched - optimized loop\n                    let ruleIndex = 0;\n                    let text : string | null = '';\n\n                    // Start from index 1 (skip full match)\n                    for (let i = 1; i < match.length; i++) {\n                        if (match[i] !== undefined) {\n                            ruleIndex = i - 1;\n                            text = match[i];\n                            break;\n                        }\n                    }\n\n                    const startPos = this.position;\n                    const textLength = text.length;\n\n                    // Update position\n                    this.position += textLength;\n\n                    // Apply transformation if exists\n                    const transform = this.ruleTransforms[ruleIndex];\n                    const value : string | null = transform ? transform(text) : text;\n\n                    return {\n                        kind        : this.ruleTypes[ruleIndex],\n                        value,\n                        span        : { start: startPos, end: this.position },\n                    };\n                }\n            }\n\n            // Fallback: error token\n            const char      = this.buffer[this.position];\n            const token     = {\n                kind        : 'error',\n                value       : char,\n                span        : { start: this.position, end: this.position },\n            };\n\n            this.position++;\n\n            return token;\n        }\n\n        *[Symbol.iterator](): Iterator<Token> {\n            let token: Token | undefined;\n            while ((token = this.next()) !== undefined) {\n                yield token;\n            }\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\n\n    /**\n    * Tokenizes source code using the provided rules\n    *\n    * @param source     - The source text to tokenize\n    * @param rules      - Rules defining how to break the source into tokens\n    * @param options    - Optional tokenization behavior settings\n    *\n    * @returns Array of tokens extracted from the source\n    */\n    export function tokenize(source: string, rules: Rules): Token[] {\n        const sourceLength = source.length;\n\n        // Early return for empty input\n        if (sourceLength === 0) { return []; }\n\n        // Use regular array and let JavaScript handle resizing\n        const tokens: Token[] = [];\n\n        // Initialize lexer with compiled rules\n        const lexer = new Lexer(rules);\n\n        // Setup lexer with input\n        lexer.setup(source);\n\n        // Optimized token iteration - avoid iterator overhead\n        let token = lexer.next();\n        while (token !== undefined) {\n            tokens.push({\n                kind    : token.kind,\n                value   : token.value!.length ? token.value : null,\n                span    : token.span\n            });\n\n            // Stop on error to match original behavior\n            if (token.kind === \"error\") break;\n\n            token = lexer.next();\n        }\n\n        return tokens;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":[]}